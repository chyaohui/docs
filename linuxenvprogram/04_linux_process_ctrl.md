> 进程是操作系统的一个核心概念，每个进程都有自己唯一的标识：进程 ID，也有自己的声明周期。

## 1、进程ID
每个进程都会有一个非负整数表示的唯一进程 ID，可以使用 getpid 函数来获取进程的 pid。每个进程都有自己的父进程，父进程又会有自己的父进程，最终都会追溯到 1 号 init 进程。


procfs 文件系统会在 /proc 下为每个进程创建一个目录，名字是该进程的 pid，目录下有很多文件，用于记录进程的运行情况和统计信息。

进程 ID 是唯一的，但进程 ID 可以重用，内核采用了延迟重用的算法，这样可以防止将新创建的进程判为使用相同进程 ID 的已经退出的进程。

那么如何实现延迟重用呢？内核采用的方法如下：
* 位图记录进程 ID 的分配情况 (0 为可用，1 为已占用)
* 将上次分配的进程 ID 记录到 last_pid 中，分配进程 ID 时，从 last_pid+1 开始找起，从位图中寻找可用的 ID。
* 如果找到位图集合的最后一位仍不可用，则回滚到位图集合的起始位置，从头开始找(从 300 开始，300 以内保留系统使用)。

可以通过 procfs 或 sysctl 命令来查看 pid_max 值：
```sh
$ cat /proc/sys/kernel/pid_max
$ sysctl kernel.pid_max

# 可以调整pid_max的值，但内核也设置了硬上限
$ sysctl -w kernel.pid_max=4194304
```


## 2、进程的层次
新进程默认会继承父进程的进程组 ID 和 会话 ID。进程组和会话是为了支持 shell 作业控制而引入的概念。当有新的用户登录 shell 时，登录进程会为这个用户创建一个会话，用户的登录 shell 就是会话的首进程，作为整个会话的 ID。


1、**进程组**

引入进程组概念，可以更方便管理这一组进程，比如这项工作放弃了，不必向每个进程一一发信号，可以直接将信号发送个进程组，组内的所有进程都会收到信号。

* 后台进程组："&"
* 前台进程组，只有一个前台进程组


2、**会话**

会话的意义在于将很多的工作囊括在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其它的工作则放在后台执行。

系统提供 setsid 函数来创建会话，要求函数的调用进程不是进程组组长，会发生如下事情：
* 创建一个新会话，会话 ID 等于进程 ID，调用进程成为会话的首进程。
* 创建一个进程组，进程组 ID 等于进程 ID，调用进程成为进程组的组长。
* 调用进程没有控制终端，如果调用前有控制终端，则这种联系会断掉。

为何？如果允许进程组组长迁移到新的会话，而进程组的其它成员仍然在老的会话中，就会出现同一进程组的进程分属不同的会话，破坏了进程组和会话的严格层次关系。

## 3、创建进程fork
Linux 中可以调用 fork 函数来创建新的进程，fork 函数会返回两次。一般创建两个完全相同的进程并没有太大意义，大部分情况下，父子进程会执行不同的代码分支。fork 函数向子进程返回 0，并将子进程的进程 ID 返回给父进程，返回失败则返回 -1，并设置 errno。

**坑**：如果 fork 返回 -1，而程序没有判断返回值，直接将 -1 当成子进程的进程号，那么后面的代码执行 kill(-1, 9) 将杀死除了 init 以外的所有进程，只要它有权限。

POSIX 标准和 Linux 都没有保证优先调度父进程，决不能对父子进程的执行顺序作任何的假设，如果确实需要某一特定顺序，那么需要使用进程间同步的手段。


fork之后的子进程完全拷贝了父进程的地址空间，包括栈、堆、代码段等。写时拷贝是指子进程的页表指向与父进程相同的物理内存页，这些页面标记为只读，一旦父子进程中有任何一方尝试修改，就会引发缺页异常，内核会尝试为该页面创建一个新的物理页面，并将内容真正地复制到新的物理页中，让父子进程真正个子拥有自己的物理内存页，然后将页表中相应的表项标记为可写。


## 2、fork父子进程与文件的关系
执行 fork 函数，内核会复制父进程所有的文件描述符。对于父进程打开的所有文件，子进程也可以操作的，无论读写，父子进程公用一套文件偏移量。

父子进程同时读写同一个文件描述符而不采取任何同步的手段，那么就会因为共享文件偏移量而使数据混乱，不可阅读。

**场景**：一般来讲，调用 exec 的子进程时，父进程打开的文件描述符应该一并关闭，内核事实上并没有主动这样做。试想 Webserver 首先以 root 权限启动，打开只有拥有 root 权限才能打开的端口和日志等文件，再降到普通用户，fork 出一些 worker 进程，在进程中解析脚本、写日志、输出结果等操作。由于子进程完全可以操作父进程打开的文件，因此子进程中的脚本只要继续操作这些文件描述符，就能越权操作 root 用户才能操作的文件。

> 为了解决这个问题，Linux 引入了 close on exec 机制，设置 FD_CLOSEXEC 标志位的文件，在子进程中调用 exec 家族函数时将相应的文件关闭，设置该标志位的方法有两种：

* open 时，带上 O_CLOSEXEC 标志位 - 推荐
* open 时如果未设置，那就在后面调用 fcntl 函数的 F_SETFD 操作来设置。


## 4、进程创建vfork
早期 fork 没有实现写时拷贝的机制，而是直接对父进程的数据段、堆和栈进行完全拷贝，效率十分低下。很多程序 fork 后执行 exec 家族函数，这更是一种浪费，因此引入 vfork 压根不会拷贝父进程的内存数据，而是直接共享。后来引入写时拷贝的机制，其效率提高了很多，这样 vfork 其实就可以退出历史舞台了，除了一些需要将性能优化到极致的场景，大部分情况不需要使用 vfork 函数。

vfork 创建子进程，共享父进程的内存数据，而系统将保证子进程先于父进程获得调度，父进程将被一直挂起，直到子进程退出或执行 exec。

参考左耳朵耗子的一篇文章《[vfork 挂掉的一个问题](https://coolshell.cn/articles/12103.html)》。

