> 本章主要包括如下内容：
* 进程可能处于的状态
* 内核如何调度进程使用 CPU 资源
* 进程如何调整优先级，以求获得更多或更少的 CPU 资源。
* 对于有实时性要求的进程如何设置调度策略以满足其要求。
* 如何把进程绑定到某个或某些 CPU 上执行。


## 1、进程的状态

进程无法始终占有 CPU 运行，原因如下：
* 进程可能需要等待某种外部条件的满足，在满足条件之前，进程无法继续执行的，如果继续占有 CPU 就是对 CPU 资源的浪费。
* Linux 是多用户多任务的操作系统，可能同时存在多个可运行的进程，进程个数可能远远多于 CPU 的个数。一个进程始终占有 CPU 对其它进程来说是不公平的，进程调度器会在合适的时机，选择合适的进程使用 CPU 资源。
* Linux 进程支持软实时，实时进程的优先级高于普通进程，实时进程之间也有优先级的差别。软实时进程进入可运行状态的时候，可能会发生抢占，抢占当前运行的进程。

### 1.1 进程状态概述
在 Linux 下，进程的状态有以下 7 种：

|进程状态|说明|
---|---
|TASK_RUNNING|可运行状态。但未必正在使用 CPU，也许在等待调度|
|TASK_INTERRUPTIBLE|可中断的睡眠状态。在等待某个条件的完成|
|TASK_UNINTERRUPTIBLE|不可中断的睡眠状态，不会被信号中断|
|TASK_STOPPED|暂停状态。进程收到信号，运行被停止|
|TASK_TRACED|被跟踪状态，进程被停止，被另一个进程跟踪|
|EXIT_ZOMBIE|僵尸状态。进程已经退出，但尚未被父进程或 init 进程收尸|
|EXIT_DEAD|真正死亡的状态。|

1.1.1 **可运行状态**

* 处于可运行状态的进程是进程调度的对象。在 Linux 中每个 CPU 都有自己的运行队列，根据进程所属调度类别的不同，可运行状态的进程会位于不同的队列上。如果是实时进程，则根据优先级落在相应优先级的队列上；如果是普通进程，则根据虚拟运行时间的大小，落在红黑树的相应位置上。调度器就可以根据一定算法从运行队列上挑选合适的进程来使用 CPU 资源。

* Linux 提供的 time 命令可以统计进程在用户态和内核态消耗的 CPU 时间：
```sh
$ time sleep 2
    real 0m2.009s
    user 0m0.001s
    sys 0m0.002s
```
time 命令统计了三种时间：实际时间、用户 CPU 时间和系统 CPU 时间。user 统计的是进程执行用户态代码消耗的 CPU 时间；sys 统计的是进程在内核态运行所消耗的 CPU 时间；real 实际时间，即进程从开始到终止。

* 如果进程在执行加减乘除或浮点数计算或排序等操作时，尽管这些操作正在消耗 CPU 资源，但是和内核没有太多的关系，CPU 大部分时间都在执行用户态的指令，这种场景下，我们称为 CPU 时间消耗在用户态。如果进程频繁地执行创建进程、分配内存、操作文件等操作，那么进程频繁陷入内核执行系统调用，这些时间都累加载进程内核态 CPU 时间。

* 最容易产生的误解是 `real time` = `user time` + `sys time` ，这种想法是错误的。在单核系统上，`real time` 总是不小于 `user time` 与 `sys time` 的总和。但在多核系统上，`user time` 与 `sys time` 的总和可以大于 `real_time`。可以计算出程序的 CPU 使用率：
```
cpu_usage = ((user time) + (sys time)) / (real time)
```
* 在多核处理器情况下，cpu_usage 如果大于 1，则表示该进程是计算密集型的进程，且 cpu_usage 的值越大，表示越充分利用了多处理器的并行运行优势；如果 cpu_usage 的值小于 1，则表示进程 IO 密集型进程，多核并行的优势并不明显。

* 如果我们需要了解正在运行的进程，内核态和用户态 CPU 时间分别是多少，可以通过 `/proc/pid/stat`:
* 系统提供了 pidstat 命令，可以获取到各个进程的 CPU 使用情况
* 获取进程实际运行时间：
```
#　ps -p 7204 -o etime,cmd,pid
    ELAPSED CMD                           PID
   23:53:04 nginx: master process /usr/  7204
```

1.1.2 **睡眠状态**

* 进程并不总是处于可运行状态。有些进程需要和慢设备打交道，比如进程和磁盘进行交互，相关的系统调用消耗的时间是非常长的，进程需要等待这些操作完成才可以执行接下来的命令。
* 有些进程需要等待某种特定条件。比如进程等待子进程退出、等待 socket 连接、尝试获得锁、等待信号量等条件满足后方可执行，而等待的时间往往是不可预估的，这种情况下，进程依然占用 CPU 就不合适了，内核回将进程的状态改变成其它状态，将其从 CPU 的运行队列中移除，同时选择其它的进程来使用 CPU 资源。

处于可中断的睡眠状态的进程，返回到可运行状态有以下两种可能：
* 等待的事件发生了，继续运行的条件满足了
* 收到未屏蔽的信号
* 当处于可中断睡眠状态的进程收到信号时，会返回 EINTR 给用户空间，程序员需要检测返回值，并作出正确的处理。
* 对于不可中断的睡眠状态，只有一种可能性能使其返回到可运行的状态，即等待的事件发生了，继续运行的条件满足了。


不可中断睡眠状态的意义在于：
* 内核中某些处理流程是不应该被打断的。
* 当进程对某些硬件进行某些操作时，需要把进程状态保护起来，避免进程与设备交互过程被打断，致使设备陷入不可控的状态。
* 该状态是一种很危险的状态，正常情况下该状态的时间会非常短暂，进程不应该长时间处于不可中断的睡眠状态。

我们可能会希望了解进程停在什么位置或在等待什么资源：
```sh
$ echo $$
3828

$ cat /proc/3828/wchan
do_wait

$ ps -p 3828 -o pid,wchan,cmd
PID WCHAN CMD
3828 wait -bash
```


