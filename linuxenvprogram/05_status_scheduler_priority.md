> 本章主要包括如下内容：
* 进程可能处于的状态
* 内核如何调度进程使用 CPU 资源
* 进程如何调整优先级，以求获得更多或更少的 CPU 资源。
* 对于有实时性要求的进程如何设置调度策略以满足其要求。
* 如何把进程绑定到某个或某些 CPU 上执行。


## 1、进程的状态

进程无法始终占有 CPU 运行，原因如下：
* 进程可能需要等待某种外部条件的满足，在满足条件之前，进程无法继续执行的，如果继续占有 CPU 就是对 CPU 资源的浪费。
* Linux 是多用户多任务的操作系统，可能同时存在多个可运行的进程，进程个数可能远远多于 CPU 的个数。一个进程始终占有 CPU 对其它进程来说是不公平的，进程调度器会在合适的时机，选择合适的进程使用 CPU 资源。
* Linux 进程支持软实时，实时进程的优先级高于普通进程，实时进程之间也有优先级的差别。软实时进程进入可运行状态的时候，可能会发生抢占，抢占当前运行的进程。

### 1.1 进程状态概述
在 Linux 下，进程的状态有以下 7 种：

|进程状态|说明|
---|---
|TASK_RUNNING|可运行状态。但未必正在使用 CPU，也许在等待调度|
|TASK_INTERRUPTIBLE|可中断的睡眠状态。在等待某个条件的完成|
|TASK_UNINTERRUPTIBLE|不可中断的睡眠状态，不会被信号中断|
|TASK_STOPPED|暂停状态。进程收到信号，运行被停止|
|TASK_TRACED|被跟踪状态，进程被停止，被另一个进程跟踪|
|EXIT_ZOMBIE|僵尸状态。进程已经退出，但尚未被父进程或 init 进程收尸|
|EXIT_DEAD|真正死亡的状态。|

1.1.1 **可运行状态**

* 处于可运行状态的进程是进程调度的对象。在 Linux 中每个 CPU 都有自己的运行队列，根据进程所属调度类别的不同，可运行状态的进程会位于不同的队列上。如果是实时进程，则根据优先级落在相应优先级的队列上；如果是普通进程，则根据虚拟运行时间的大小，落在红黑树的相应位置上。调度器就可以根据一定算法从运行队列上挑选合适的进程来使用 CPU 资源。

* Linux 提供的 time 命令可以统计进程在用户态和内核态消耗的 CPU 时间：
```sh
$ time sleep 2
    real 0m2.009s
    user 0m0.001s
    sys 0m0.002s
```
time 命令统计了三种时间：实际时间、用户 CPU 时间和系统 CPU 时间。user 统计的是进程执行用户态代码消耗的 CPU 时间；sys 统计的是进程在内核态运行所消耗的 CPU 时间；real 实际时间，即进程从开始到终止。

* 如果进程在执行加减乘除或浮点数计算或排序等操作时，尽管这些操作正在消耗 CPU 资源，但是和内核没有太多的关系，CPU 大部分时间都在执行用户态的指令，这种场景下，我们称为 CPU 时间消耗在用户态。如果进程频繁地执行创建进程、分配内存、操作文件等操作，那么进程频繁陷入内核执行系统调用，这些时间都累加载进程内核态 CPU 时间。

* 最容易产生的误解是 `real time` = `user time` + `sys time` ，这种想法是错误的。在单核系统上，`real time` 总是不小于 `user time` 与 `sys time` 的总和。但在多核系统上，`user time` 与 `sys time` 的总和可以大于 `real_time`。可以计算出程序的 CPU 使用率：
```
cpu_usage = ((user time) + (sys time)) / (real time)
```
* 在多核处理器情况下，cpu_usage 如果大于 1，则表示该进程是计算密集型的进程，且 cpu_usage 的值越大，表示越充分利用了多处理器的并行运行优势；如果 cpu_usage 的值小于 1，则表示进程 IO 密集型进程，多核并行的优势并不明显。

* 如果我们需要了解正在运行的进程，内核态和用户态 CPU 时间分别是多少，可以通过 `/proc/pid/stat`:
* 系统提供了 pidstat 命令，可以获取到各个进程的 CPU 使用情况
* 获取进程实际运行时间：
```
#　ps -p 7204 -o etime,cmd,pid
    ELAPSED CMD                           PID
   23:53:04 nginx: master process /usr/  7204
```

1.1.2 **睡眠状态**

* 进程并不总是处于可运行状态。有些进程需要和慢设备打交道，比如进程和磁盘进行交互，相关的系统调用消耗的时间是非常长的，进程需要等待这些操作完成才可以执行接下来的命令。
* 有些进程需要等待某种特定条件。比如进程等待子进程退出、等待 socket 连接、尝试获得锁、等待信号量等条件满足后方可执行，而等待的时间往往是不可预估的，这种情况下，进程依然占用 CPU 就不合适了，内核回将进程的状态改变成其它状态，将其从 CPU 的运行队列中移除，同时选择其它的进程来使用 CPU 资源。

处于可中断的睡眠状态的进程，返回到可运行状态有以下两种可能：
* 等待的事件发生了，继续运行的条件满足了
* 收到未屏蔽的信号
* 当处于可中断睡眠状态的进程收到信号时，会返回 EINTR 给用户空间，程序员需要检测返回值，并作出正确的处理。
* 对于不可中断的睡眠状态，只有一种可能性能使其返回到可运行的状态，即等待的事件发生了，继续运行的条件满足了。


不可中断睡眠状态的意义在于：
* 内核中某些处理流程是不应该被打断的。
* 当进程对某些硬件进行某些操作时，需要把进程状态保护起来，避免进程与设备交互过程被打断，致使设备陷入不可控的状态。
* 该状态是一种很危险的状态，正常情况下该状态的时间会非常短暂，进程不应该长时间处于不可中断的睡眠状态。

我们可能会希望了解进程停在什么位置或在等待什么资源：
```sh
$ echo $$
3828

$ cat /proc/3828/wchan
do_wait

$ ps -p 3828 -o pid,wchan,cmd
PID WCHAN CMD
3828 wait -bash
```

1.1.3 **睡眠进程和等待队列**

进程但凡需要休眠，必然是等待某种资源或等待某个事件，内核必须想办法将进程与它等待的资源或事件关联起来，当等待的资源可用或事件发生时，可以及时唤醒相关的进程，内核采用的方法是等待队列。

如果存在多个进程在等待同一个条件满足或同一事件发生，那么当条件满足时，应该把所有进程一并唤醒还是只唤醒某一个或多个进程？答案是具体情况具体分析，比如多个进程等待临界区资源，当锁的持有者释放锁时，如果内核将所有等待该锁的进程一起唤醒，那么最终也只能有一个进程竞争到锁资源，而大多数的竞争者不过是从休眠中醒来，然后又继续休眠，这会浪费 CPU 资源，如果等待队列中的进程数目很大，还会严重影响性能。这就是所谓的惊群效应(thundering herd problem)


1.1.4 **TASK_KILLABLE状态**

内核自 2.6.25 版本引入一种新的状态即 TASK_KILLABLE 状态。可中断的睡眠状态太容易被信号打断，与之对应，不可中断的睡眠状态完全不可以被信号打断，又容易失控，两者都比较极端。而内核新引入的 TASK_KILLABLE 状态则介入两者之间，是一种调和状态。该状态行为上类似于 TASK_UNINTERRUPTIBLE 状态，但是进程收到致命信号时，进程会被唤醒。


1.1.5 **TASK_STOPPED和TASK_TRACED**

TASK_STOPPED 状态是一种比较特殊的状态，SIGSTOP 等信号可以将进程暂时停止，SIGSTOP 具有和 SIGKILL 类似的属性，不能忽略，不能安装新的信号处理函数，不能屏蔽。当处于 TASK_STOPPED 状态的进程收到 SIGCONT 信号后，可以恢复进程的执行。

TASK_TRACED 是被跟踪的状态，进程会停下来等待跟踪它的进程对它进行进一步的操作，当使用 gdb 调试程序，当进程在断点处停下来时，此时进程处于该状态。


1.1.6 **EXIT_ZOMBIE和EXIT_DEAD**

两种状态的区别，如果父进程没有将 SIGCHLD 信号的处理函数重设为 SIG_IGN，或没为 SIGCHLD 设置 SA_NOCLDWAIT 标志位，那么子进程退出后，会进入僵尸状态等待父进程或 init 收尸，否则直接进入 EXIT_DEAD。

### 2、观察进程状态

通过 proc 文件系统中，可以查看进程的状态：
```sh
$ cat /proc/7204/status | grep "State:"
State:	S (sleeping)
```

|procfs 中的值|进程状态|
---|---
|R(running)|TASK_RUNNING|
|s(sleeping)|TASK_INTERRUPTIBLE|
|D(disk sleep)|TASK_UNINTERRUPTIBLE|
|t(stopped)|TASK_STOPPED|
|t(tracing stop)|TASK_TRACED|
|Z(zombie)|EXIT_DEAD|
|X(dead)|EXIT_DEAD|


## 进程调度概述

* Linux 是多任务的操作系统。对于单处理器系统，多个进程仅仅是轮流使用 CPU 资源；只有在多处理器系统中，多个进程才能真正做到并行执行。

* 多任务系统分为：非抢占式和抢占式。非抢占式，下一个任务被调度的前提是当前进程主动让出 CPU 的使用权；而抢占式，在某时间点操作系统可以将正在运行的进程调度出去，选择其它进程来执行。


设计一个优秀的进程调度器绝不是一件容易的事情，它还有很多事情需要考虑，很多目标需要达成：
* 公平：每个进程都可以获得公平的调度机会
* 良好的调度延迟：尽量确保进程在一定的时间范围内总能够获得调度的机会
* 差异化：允许重要的进程获得更多的执行时间
* 支持软实时进程：软实时进程，比普通进程具有更高的优先级
* 负载均衡：多个 CPU 之间的负载均衡，不能出现一些 CPU 很忙，而另一些 CPU 很闲的情况。
* 高吞吐量：单位时间内完成的进程个数尽可能多
* 简单高效：调度算法要高效，不应该在调度上话费太长的时间
* 低耗电量：在系统并不繁忙时，降低系统的耗电量


目前 Linux 采用的是每个 CPU 都要有自己的运行队列，每个 CPU 去自己的运行队列中选择进程，降低了竞争，另外一个好处是缓存重利用。这样也会带来一种风险：CPU 之间负载不均衡。load_balance可以通过将任务从一个 CPU 的运行队列迁移到另一个 CPU 的运行队列，来保持 CPU 之间的负载均衡。

进程调度的职责是挑选下一个执行的进程，如果下一个被调度到的进程和调度前运行的进程不是一个，则执行上下文切换，将新选择的进程投入运行。

从内核 2.6 版本开始，Linux 不仅支持用户态抢占，也开始支持内核态抢占，内核抢占可以保证系统的响应时间，当高优先级的任务一旦就绪，总能及时得到 CPU 的控制权，但不是所有时机都允许发生内核抢占，比如自旋锁持有期间不允许发生内核抢占，否则可能会导致其它 CPU 长期不能获得锁而死等。


