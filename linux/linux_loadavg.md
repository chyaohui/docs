> 深入理解 Linux 的“平均负载”

## 使用 uptime 查看负载

通常每次系统变慢时，我们都会使用 top 或 uptime 来查看系统的负载情况，输出如下信息：
```bash
$ uptime
  22:06:46 up 1096 days,  9:04,  1 user,  load average: 0.08, 0.12, 0.13
```
* `22:06:46`：系统当前时间
* `up 1096 days,  9:04`：系统运行时间
* `1 user`：当前登录用户数量
* `load average: 0.08, 0.12, 0.13`：系统过去 1 分钟、5 分钟、15 分钟的平均负载


## 平均负载的真正含义

uptime 列出的内容，前边都很容易理解，而对于 load average 你真的理解其中的含义么。平均负载我们在工作中总会看到，总会用到，但是貌似也说不明白到底什么是平均负载。本文来学习和总结一下，如何理解这个最常见、最重要的系统指标。

* **平均负载**

简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。

* **可运行状态的进程**

所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态(Running 或 Runnable)的进程。

* **不可中断状态的进程**

不可中断状态的进程是正处于内核态关键流程中的进程，且这些流程是不可打断的，比如常见的是等待硬件设备的 IO 响应，也就是我们在 ps 命令中看到的 D 状态的进程。比如当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程中断打断的，这时进程就处于不可中断状态。所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制。

所以我们可以简单理解为，平均负载其实就是平均活跃进程数，平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值(暂不用深究这个概念)。那么最理想的，就是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用，比如当平均负载为 2 时，意味着什么呢？

* 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用
* 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲
* 在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。


## 平均负载为多少时合理

理解了平均负载的含义，那么三个时间段的平均负载多大时能说明系统负载高？多小时说明系统负载很低呢？我们知道，平均负载最理想的情况是等于 CPU 个数，所以在评判平均负载时，首先要知道系统有几个 CPU，可以通过 `/proc/cpuinfo` 来读取，比如：
```bash
$ cat /proc/cpuinfo | grep "processor" | wc -l
  2
```
有了 CPU 个数，我们就可以判断出当平均负载比 CPU 个数还大的时候，系统已经出现了过载。不过平均负载有三个数值，到底该参考哪一个呢？

实际上这三个值都需要看，三个不同时间间隔的平均值，其实给我们提供了，分析系统负载趋势的数据来源，让我们能更全面、更立体地理解目前的负载状况。
* 如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那说明系统负载很平稳。
* 如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。
* 如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以需要持续观察。一旦 1 分钟的平均负载超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析并优化了。

在实际生产环境中，当平均负载高于 CPU 数量 70% 的时候，我们应该分析排查负载高的问题了，一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能。70% 这个数字不是绝对的，最好是把系统的平均负载监控起来，根据历史数据，判断负载的变化趋势，当发现负载有明显升高趋势时，再去做分析和调查。


## 平均负载与 CPU 使用率的关系

我们经常容易把平均负载和 CPU 使用率混淆，你可能会疑惑，既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？

我们还要回到平均负载的含义上，平均负载是指单位时间内处于可运行状态和不可中断状态的进程数。所以它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 IO 的进程。而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应，比如：

* CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的。
* IO 密集型进程，等待 IO 也会导致平均负载升高，但 CPU 使用率不一定很高。
* 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。


## 平均负载案例分析

* 预先安装 stress 和 sysstat 包
  ```bash
  $ yum install stress sysstat
  ```
* stress 是一个 Linux 系统压力测试工具，我们用作异常进程模拟平均负载升高的场景。
* sysstat 包含了常用的 Linux 性能工具，包括：iostat、pidstat、mpstat、sar 等，用来监控和分析系统的性能。
* mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
* pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、IO 以及上下文切换等性能指标。

先观察下当前服务器的平均负载情况：
```bash
$ uptime
  18:35:21 up 14 days,  2:45,  7 users,  load average: 0.00, 0.01, 0.05
```

* 场景一：CPU 密集型进程

首先，我们在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景：
```bash
$ stress --cpu 1 --timeout 600
```
接着，在第二个终端运行 uptime 查看平均负载的变化情况：
```bash
$ watch -d uptime
  18:42:21 up 14 days,  2:52,  7 users,  load average: 1.01, 0.71, 0.31
```
最后，在第三个终端运行 mpstat 查看 CPU 使用率的变化情况：
```bash
$ mpstat -P ALL 5
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:30:06   CPU    %usr  %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:30:11   all   50.05   0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
13:30:11     0    0.00   0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13:30:11     1  100.00   0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
```
从终端二可以看到，1 分钟平均负载慢慢增加到 1.00，而从终端三中正好有一个 CPU 使用率为 100%，但它的 iowait 只有 0，说明平均负载的升高是由于 CPU 使用率为 100%。那么到底是哪个进程导致了 CPU 使用率为 100% 呢？可以使用 pidstat 来查询：
```bash
$ pidstat -u 5 1
13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress
```
明显看到 stress 进程的 CPU 使用率为 100%。

* 场景二：IO 密集型进程

首先，运行 stress 命令，这次模拟 IO 压力，即不停地执行 sync：
```bash
$ stress -i 1 --timeout 600
```
还是在第二个终端运行 uptime 查看平均负载的变化情况：
```bash
$ watch -d uptime
  ..., load average: 1.06, 0.58, 0.37
```
然后，第三个终端运行 mpstat 查看 CPU 使用率的变化情况：
```bash
$ mpstat -P ALL 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99
```
从这里可以看出，1 分钟的平均负载增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到 23.87，而 iowait 高达 67.53%，说明平均负载升高是由于 iowait 的升高。
```bash
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat
```
可以发现，还是 stress 进程导致的。


* 场景三：大量进程的场景

当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。使用 stress 模拟 8 个进程：
```bash
$ stress -c 8 --timeout 600
```
由于系统只有 2 个 CPU，明显比 8 个进程要少得多，因而系统的 CPU 处于严重过载状态，平均负载高达 7.97:
```bash
$ uptime
...,  load average: 7.97, 5.93, 3.02
```
接着再运行 pidstat 来看一下进程的情况：
```bash
$ pidstat -u 5 1
14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat
```
可以看出，8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间(也就是 %wait 列)高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。

## 小结

平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但只看平均负载本身，我们并不能直接发现，到底是哪里出现了瓶颈。在理解平均负载时，也要注意：

* 平均负载高有可能是 CPU 密集型进程导致的；
* 平均负载高并不一定代表 CPU 使用率高，还有可能是 IO 更繁忙了；
* 当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。
