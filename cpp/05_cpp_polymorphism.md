> 多态

* 非虚的世界
* 虚函数、覆盖和多态
* 覆盖的条件
* 多态的条件
* 纯虚函数、抽象类和纯抽象类
* 好莱坞模式
* 虚函数表与动态绑定
* 运行时类型信息（RTTI）
* 虚析构
* 抽象工厂模式



## 非虚的世界
* 对象的自恰性
    - 对同样的函数调用，每个对象都会做出恰当的响应
* 通过指向子类对象的基类指针调用函数
    - 只能调用基类的成员函数，虽然指针指向子类对象
    - 一旦调用子类所特有的成员函数，将引发编译错误
* 通过指向基类对象的子类指针调用函数
    - 可以调用子类的成员函数，尽管指针指向基类对象
    - 直接或间接地访问子类的成员变量，后果不可预知
    - 也可以调用基类的成员函数！！！！！！！！！！
    - 也可以访问基类的成员变量！！！！！！
* 名字隐藏
    - 子类的成员函数、成员变量隐藏基类的同名成员函数和成员变量
    - 在基类中只要与子类同名的成员函数或成员变量都被隐藏

## 二、虚函数、覆盖、多态
* 虚函数
    - 形如下边的成员函数，称为虚函数或方法
    ```
    class  类名{
        virtual  返回类型  函数名（形参表）{... ...}
    };
    ```
  
* 覆盖
    - 如果子类的成员函数和基类的虚函数具有相同的函数原型，那么该成员函数就也是虚函数，无论其是否带有 virtual 关键字，且对基类的虚函数构成 覆盖。
* 多态
    - 如果子类提供了对基类虚函数的有效覆盖，那么通过一个指向子类对象的基类指针，或者 引用子类对象的基类引用，调用该虚函数，实际被调用的将是子类中的覆盖版本，而非基类中的原始版本，这种现象称为多态。
    - 多态的重要意义在于，一般情况下，调用哪个类的成员函数是由调用者指针或引用本身的类型决定的，而当多态发生时，调用哪个类的成员函数则完全由调动者指针或引用的实际目标对象的类型决定
## 三、覆盖的条件
* 有效的虚函数需要满足如下条件：
    - 该函数必须是成员函数，既不能是全局函数也不能是静态成员函数
    - 该函数必须在基类中用 virtual 关键字声明为虚函数
    - 覆盖版本与基类版本必须拥有完全相同的签名，即函数名、形参表、常属性严格一致

