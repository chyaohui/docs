> C++编程基础知识点

- [x] 基本介绍
- [ ] 第一个C++程序
- [ ] 名字空间
- [ ] 结构、联合、枚举
- [ ] 布尔类型
- [ ] 操作符别名
- [ ] 重载
- [ ] 缺省参数和哑元
- [ ] 内联
- [ ] 动态内存分配
- [ ] 引用
- [ ] 显式类型转换
- [ ] 来自C++社区的建议

# 一、基本介绍
## 1.C++的发展
- 80年代，贝尔实验室发明C with Classes   --- 本贾尼
- 1983年，正式命名为C++
- 1987年，GNU 推出C++的标准
- 1992年，微软、IBM推出推出他们的标准
- 1998年，ISO推出C++98标准
- 2003年，ISO推出C++03标准
- 2011年，ISO推出C++0x标准

## 2.C++和C语言的联系和区别
- C++包含整个C，C++是建立在C语言基础上的
- C++是强类型语言，比C语言对类型检查更加严格
- C++语言比C语言更加丰富
- C++支持面向对象(C++在宏观上面向对象，微观上是面向过程)
- C++支持运算符重载
- C++支持异常处理
- C++支持泛型编程(类型通用编程)

# 二、第一个C++程序
## 1.编译器g++
也可以用gcc，但要加上-lstdc++，g++其实就是gcc，gcc是一组程序，包括g++
```bash
$ gcc first.cpp -lstdc++
```
## 2.扩展名
常用扩展名：.cpp | .cc | .C | .cxx 推荐使用.cpp。也可以用.c，但是要加上-x c++    
```bash
$ gcc first.c -x c++
```
## 3.头文件
- 头文件位置: /usr/include/c++/4.x
- C++标准的头文件没有.h(与C的头文件没有本质区别): <iostream>
- C的头文件在C++中使用: <cstdio> <cstring> <ctime>
- 使用系统的头文件(非标C头文件): <pthread.h> <sys/types.h>

## 4.流操作
```cpp
cout << "Hello World.";
cin >> a;
// 也可以使用 scanf 和 printf
```
## 5.使用std空间下的相关数据
所有标准类型、对象和函数都位于`std`命名空间中
```cpp
std::cout       /* 标准输出对象 */
std::endl       /* 标准结束行的对象 */
std::cin        /* 标准的输入对象 */
std::cout << "hello world" << std::endl;
```
前面加空间名，是最根本的使用方式

## 6.使用声明的方式
使用声明的方式，能简化一个对象的使用
```cpp
using std::cout;
using std::endl;
cout << "hello world" << endl;
```
## 7.使用指令的方式
使用指令的方式，能简化多个对象的使用
```cpp
using namespace std;
cout << "hello world" << endl;
```
# 三、名字空间
## 1.为什么需要名字空间(why)
- 划分逻辑单元
- 避免名字冲突

## 2.什么是名字空间(what)
- 名字空间定义：把一组相关的数据，放入一个逻辑结构中统一管理
- 名字空间合并
- 声明定义分开
- 声明和定义分开后，编译器可以帮助捕捉到例如拼写错误或类型不匹配一类的错误

## 3.怎样用名字空间(how)
- 作用域限定符"::"
- 名字空间指令: 本空间中所有的标识符在该指令之后都可见(可以直接使用)
- 名字空间声明: 空间中声明过的标识符可以直接使用
- 注：局部、全局、名字空间(可以看作是作用域，限制变量、函数等的使用范围)

## 4.无名名字空间(匿名名字空间)
- 不属于任何有名名字空间的标识符，隶属无名命名空间
- 无名名字空间的成员，直接通过::访问(作用域限定符)
```cpp
 namespace{   /* 无名名字空间 */
    int a=15;
    ... ...
    void test(){
    }
}
::test();   /* 只有加上::才代表调用匿名空间的数据 */
```

## 5.名字空间嵌套与名字空间别名
- 内层标识符隐藏外层同名标识符
- 嵌套的名字空间需要逐层分解
- 可通过名字空间别名简化书写
- `namespace ns_four = ns1::ns2::ns3::ns4;`

## 6.名字空间的总结
一个名字空间也是一个作用域,一个程序越大,通过名字空间去描述其中逻辑上独立的各个部分也就越重要。

理想情况是,程序里的每个实体都属于某个可以识别的逻辑单位 ( 模块 ), 所以,一个良好的程序里的每个声明都应该位于某个名字空间里,以此指明它在程序中所扮演的角色。

作用域1：如果一个全局变量a和名字空间的一个变量a名字重复，而在使用时将该名字空间的变量可见，以后再使用变量a时，若需要使用全局变量a则需要::a的使用方式，如果使用虽然设定可见的名字空间的变量a时，应该 abc::a的使用方式，不能简单的使用变量a，这样编译器会出错，提示对a的引用有歧义

作用域2：
    如果一个局部变量a和名字空间的变量a名字重复，则在函数中局部使用时可以按默认的方式使用a即可，默认使用的是局部变量a，即使名字空间指令在局部变量a的定义之下。局部变量a不会被系统放在无名名字空间中。如果想使用名字空间的变量则需要   abc::a的方式使用
    如果使用局部变量的::a，则编译器报错（‘::a’尚未声明，因为系统没有将局部变量放入无名名字空间，只是将全局变量放入无名名字空间）
