# C++编程基础知识点

- 基本介绍
- 第一个C++程序
- 名字空间
- 结构、联合、枚举
- 布尔类型
- 操作符别名
- 重载
- 缺省参数和哑元
- 内联
- 动态内存分配
- 引用
- 显式类型转换
- 来自C++社区的建议

## 一、基本介绍
### 1.C++的发展
- 80年代，贝尔实验室发明C with Classes   --- 本贾尼
- 1983年，正式命名为C++
- 1987年，GNU 推出C++的标准
- 1992年，微软、IBM推出推出他们的标准
- 1998年，ISO推出C++98标准
- 2003年，ISO推出C++03标准
- 2011年，ISO推出C++0x标准

### 2.C++和C语言的联系和区别
- C++包含整个C，C++是建立在C语言基础上的
- C++是强类型语言，比C语言对类型检查更加严格
- C++语言比C语言更加丰富
- C++支持面向对象(C++在宏观上面向对象，微观上是面向过程)
- C++支持运算符重载
- C++支持异常处理
- C++支持泛型编程(类型通用编程)

## 二、第一个C++程序
### 1.编译器g++
也可以用gcc，但要加上-lstdc++，g++其实就是gcc，gcc是一组程序，包括g++
```bash
$ gcc first.cpp -lstdc++
```
### 2.扩展名
常用扩展名：.cpp | .cc | .C | .cxx 推荐使用.cpp。也可以用.c，但是要加上-x c++    
```bash
$ gcc first.c -x c++
```
### 3.头文件
- 头文件位置: /usr/include/c++/4.x
- C++标准的头文件没有.h(与C的头文件没有本质区别): <iostream>
- C的头文件在C++中使用: <cstdio> <cstring> <ctime>
- 使用系统的头文件(非标C头文件): <pthread.h> <sys/types.h>

### 4.流操作
```cpp
cout << "Hello World.";
cin >> a;
// 也可以使用 scanf 和 printf
```
### 5.使用std空间下的相关数据
所有标准类型、对象和函数都位于`std`命名空间中
```cpp
std::cout       /* 标准输出对象 */
std::endl       /* 标准结束行的对象 */
std::cin        /* 标准的输入对象 */
std::cout << "hello world" << std::endl;
```
前面加空间名，是最根本的使用方式

### 6.使用声明的方式
使用声明的方式，能简化一个对象的使用
```cpp
using std::cout;
using std::endl;
cout << "hello world" << endl;
```
### 7.使用指令的方式
使用指令的方式，能简化多个对象的使用
```cpp
using namespace std;
cout << "hello world" << endl;
```
## 三、名字空间
### 1.为什么需要名字空间(why)
- 划分逻辑单元
- 避免名字冲突

### 2.什么是名字空间(what)
- 名字空间定义：把一组相关的数据，放入一个逻辑结构中统一管理
- 名字空间合并
- 声明定义分开
- 声明和定义分开后，编译器可以帮助捕捉到例如拼写错误或类型不匹配一类的错误

### 3.怎样用名字空间(how)
- 作用域限定符"::"
- 名字空间指令: 本空间中所有的标识符在该指令之后都可见(可以直接使用)
- 名字空间声明: 空间中声明过的标识符可以直接使用
- 注：局部、全局、名字空间(可以看作是作用域，限制变量、函数等的使用范围)

### 4.无名名字空间(匿名名字空间)
- 不属于任何有名名字空间的标识符，隶属无名命名空间
- 无名名字空间的成员，直接通过::访问(作用域限定符)

```cpp
 namespace{   /* 无名名字空间 */
    int a=15;
    ... ...
    void test(){
    }
}
::test();   /* 只有加上::才代表调用匿名空间的数据 */
```

### 5.名字空间嵌套与名字空间别名
- 内层标识符隐藏外层同名标识符
- 嵌套的名字空间需要逐层分解
- 可通过名字空间别名简化书写
- `namespace ns_four = ns1::ns2::ns3::ns4;`

## 四、C++结构体、联合、枚举
### 1.C++结构体
- 声明或定义结构型变量，可以省略`struct`关键字
- 可以定义成员函数，在结构体的成员函数中可以直接访问该结构体的成员变量，无需通过`.`或`->`
- 其实函数的存储区不在堆栈，仍在代码区，放在一块使用方便，将数据和操作封装
- C++中没有任何成员的结构体大小是1(C语言的是0)
- C++中的`struct`与`class`只有一个区别: struct的默认权限为public，class的默认权限是private
- C++中`struct`的存在是为了兼容C语法，推荐在C++中尽可能少的使用`struct`, 而使用`class` 
- C++与C中的`struct`从思想上完全不是一个东西，C中主要是数据结构，C++中主要是面向对象的类

### 2.C++联合
- 多个变量共享一段内存
- 声明或定义联合变量，可以省略`union`关键字
- 支持匿名联合
- C++匿名联合并不表示某种类型，用来表示联合中数据在内存中的布局形式
- 计算机(大端、小端序列，网络序列永远是大端序列)——小低低(计算机字节序)

```cpp
union var{
    char c[4]; int i;
};
union var data;
data.c[0] = 0x04; data.c[1] = 0x03;
data.c[2] = 0x02; data.c[3] = 0x11; 
printf("%x\n",data.i);  // 数组中下标低的，地址也低 结果为：11020304
// 第2种方式：
union var{ int data; char i; }test;
test.data = 1; if (test.i == 1) printf("little endian");
```

### 3.C++枚举
- 声明或定义枚举型变量，可以省略`enum`关键字
- 枚举本质上是整数，所以枚举可以赋值给int，但C++类型检查严格，int值不能赋值枚举变量

## 五、参数与零值
### 1.C++零值
只有 `NULL`、`'\0'`、`0`、`false` 表示0值(假)

### 2.C++无参
- C语言中无参代表可以有任意个参数，void代表无参
- C++中无参代表没有任何参数，void可以继续使用
- C++函数在调用前必须声明，不再支持C语言的隐式声明
- C++不再支持(C语言函数不设计返回值，默认返回int)，main函数除外

## 六、函数重载
### 1.函数重载相关概念
- 同一作用域中，函数名相同，参数表不同的函数，且同作用域中对其可见才能构成函数重载
- 不同作用域中同名函数遵循标识符隐藏原则
- 参数列表表的类型、数量、顺序，与返回值无关
- 重载的优点：对函数的实现者，函数的名字简单；对函数的调用者，不用考虑类型，方便调用

### 2.函数重载的原理
- C++重载是通过换名实现的，编译器会根据函数名和参数列表的不同，生成新的函数名，本质的机制与C一样
- 通过 extern "C" 可以要求C++编译器按照C方式处理函数接口，即不做换名，当然也就无法重载

### 3.函数重载解析
- 函数重载是根据参数列表来选择，有时列表并非完全匹配，编译器根据匹配度进行评分，然后根据分数选择分数最高的匹配
- 完全匹配 -> 常量转换 -> 升级转换 -> 标准转换 -> 自定义转换 -> 省略号匹配
- 完全匹配： 是编译器的最佳选择方案，首选
- 常量转换： 是将非常量参数，转换为常类的参数，变得更安全，匹配度相对较高
- 升级转换： char ->int 是升级转换，从1字节转换到4字节，更安全，但能转换int就不会转换long long int
- 标准转换： double -> int会有小数点后边数据丢失，数据损失;int -> double会有精度损失的; 两个都属于标准转换
- 省略号转换：匹配度最低，因为它是可变长参数，最不可靠的
- 通过示例程序理解C++重载原理

```cpp
extern "C" {
    int add(int a,int b){
        return a+b;
    }
    double add(double a,double b){
        return a+b;
    }   /* 编译出错，没有换名，不能构成重载关系 */
}       /* 大括号内所有的g++编译都不改名 */
```

### 4.C++与C的相互调用
- 重载导致C和C++相互调用会出现链接时名字不匹配，而发生调用错误

C调用C++代码：
```
a. 定义一个头文件: mymath.h 不需要 extern "C"
b. 编写被调函数的实现: mymath.cpp extern "C" int add(int a,int b) { ... }
c. 编写主调函数main并调用，调用cpp函数，加上头文件可以
d. g++ test.cpp -c -otest; gcc main.c -omain test; ./main
```
C++调用C代码：
```
a. 定义一个头文件: mymath.h 需要加 extern "C" int add(int a,int b);
b. 编写被调函数的实现: mymath.c 不需要加extern "C"，因为.c函数本身生成代码不会改名字
c. 编写主调函数main.cpp并调用，加上include "mymath.h" 因为头文件中声明了extern "C";
   所以main.cpp与被调函数生成代码编译链接时都不会改名字，可以正常调用、链接使用
```

## 七、缺省参数和哑元
### 1.缺省参数
- 可以为函数的参数指定缺省值
- 如果函数的声明和实现是分开的，缺省值只能是在函数声明中指定，否则编译器报错
- 函数参数缺省值是在编译时确定的，遇到函数调用语句时，编译器将用缺省的实参对应的形参缺省值替换
- 如果函数的某一个参数具有缺省值，那么该参数后面所有参数必须都具有缺省值
- 不要因为缺省参数而导致重载歧义

### 2.哑元
- 只指定类型而不指定名称的函数参数，称为哑元
- 保证函数的向下兼容
- 形成函数的重载版本
- 作用: 向前兼容、区别函数
- 新老用户都能用，老用户仍然可以在调用函数中写参数，新用户就会明白这是哑元，不会对这个参数不理解

实例1(重载版本):
```cpp
// 需求：一个是对两个整数求和，一个是2个整数求差，但要求函数名相同
int cal (int x, int y){
    return x + y;
}
int cal (int x, int y, int){
    return x - y;
}
```
实例2:
```cpp
int operator++();           /* 默认表达前++ */
int operator++(int);        /* 这是后++ */
```

## 八、内联函数
- 内联就是用函数已被编译好的二进制代码，替换对该函数的调用指令
- 内联在保证函数特性的同时，避免了函数调用开销
- 执行效率将会增高，它既有宏函数的高效特性，也有函数的类型特性
- 只有频繁调用的简单函数才适合内联
- 若函数在类声明中直接定义,则自动被优化为内联,否则可在其声明处加上inline关键字
- inline关键字仅表示期望该函数被优化为内联，但是是否适合内联则完全由编译器决定
- 稀少被调用的复杂函数(>200行)和递归函数都不适合内联


