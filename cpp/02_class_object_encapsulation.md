# 类和对象（封装性）

* 面向对象
* 类和对象
* 类的定义和实例化
* 构造函数和初始化表
* this 指针
* 常函数和常对象
* 析构函数
* 拷贝构造和拷贝赋值
* 静态成员
* 成员指针


## 一、面向对象
* 为什么要面向对象 `WHY`
  - 相比于分而治之的结构化程序设计，强调大处着眼的面向对象程序设计思想，更适合于开发大型软件
  - 得益于数据抽象、代码复用等面向对象的固有特征，软件开发的效率获得极大地提升，成本即大幅降低
  - 面向对象技术在数据库、网络通信、图形界面等领域的广泛应用，已催生出各种设计模式和应用框架
  - 面向对象技术的表现如此出众，以至于那些原本并不直接支持面向对象特性的语言(例如 C)，也在越来越多地通过各种方法模拟一些面向对象的软件结构

* 什么是面向对象 `WHAT`
  - 万物皆对象，这是人类面对世界最朴素，最自然的感觉、想法和观点
  - 把大型软件看成是一个由对象组成的社会
  - 对象拥有足够的智能，能够理解来自其它对象的信息，并以适当的行为作出反应
  - 对象能够从高局对象继承属性和行为，并允许低层对象从自己继承属性和行为等
  - 编写程序的过程就是描述对象属性和行为的过程，凭借返种能力使问题域和解域获得最大程度的统一。
  - 面向对象的三大要件：封装、继承和多态。

* 怎样面向对象 `HOW`
  - 至少掌握一种面向对象的程序设计语言，如 C++
  - 深入理解封装、继承和多态等面向对象的重要概念
  - 精通一种元语言，如 UML，在概念层次上描述设计
  - 学习设计模式，源自多年成功经验的积累和总结


## 二、类和对象

* 拥有相同属性和行为的对象被分成一组，即一个类
* 类可用于表达那些不能直接与内置类型建立自然映射关系的逻辑抽象
* 类是一种用户自定义的复合数据类型，即包括表达属性的成员变量，也包括表达行为的成员函数
* 类是现实世界的抽象，对象是类在虚拟世界的实例


## 三、类的定义与实例化

**类的一般形式：**

```cpp
class 类名: 继承方式 基类, ... {                   /* 继承方式 */
    访问控制限定符:
    类名(形参表)：成员变量(初值), ... {             /* 构造函数 */
        函数体;                                  /* 初始化表 */
    }
    ~类名(void){函数体;}                          /* 析构函数 */
    返回类型 函数名(形参表) 常属性 异常说明 {函数体;}  /* 成员函数 */
    数据类型 变量名;                               /* 成员变量 */
};
```
注：在类内定义的成员函数默认是内联函数；若成员函数的声明和实现分开，如果需要手动加 inline
**类的控制限定符**

* public    公有成员 ———— 谁都可以访问
* protected 保护成员 ———— 只有自己和子类可以访问
* private   私有成员 ———— 只有自己可以访问

**访问控制限定符**

* 在 C++ 中，class 和 struct 没有本质性差别，唯一不同在于：
  - class  的缺省访问控制属性为私有(private)
  - struct 的缺省访问控制属性为公有(public)
* 访问控制限定符仅作用于类，而非作用于对象，因此同一个类的不同对象，可以互相访问非公有部分
* 对不同成员的访问控制属性加以区分，体现了 C++ 作为面向对象程序设计语言的封装特性

**构造函数**

* 函数名与类名相同，且没有返回值
* 在创建对象时自动被调用，且仅被调用一次，主要目的是初始化对象
  - 对象定义语句
  - new 操作符
* 为成员变量赋初值，分配资源，设置对象的初始状态
* 对象的创建过程
  - 为整个对象分配内存空间
  - 以构造实参调用构造函数
    * 构造基类部分
    * 构造成员变量
    * 执行构造代码

**类的声明和实现可以分开**

```cpp
class 类名 {
    返回类型 函数名 (形参表);
};

返回类型 类名::函数名 (形参表) {
    函数体;
};
```
**栈中对象的创建与销毁**

* 在栈中创建单个对象
  - 类名 对象;  /* 注意不要加() */
  - 类名 对象(实参表);
* 在栈中创建对象数组
  - 类名 对象数组[n];
  - 类名 对象数组[n] = {类名 (实参表),... ...};
  - 类名 对象数组[] = {类名 (实参表),... ...};

**堆中对象的创建与销毁**

* 在堆中创建/销毁单个对象
  - 类名* 对象指针 = new 类名;
  - 类名* 对象指针 = new 类名 ();
  - 类名* 对象指针 = new 类名 (实参表);
  - delete 对象指针;
* 在堆中创建/销毁对象数组
  - 类名* 对象数组指针 = new 类名[元素个数];
  - 类名* 对象数组指针 = new 类名[元素个数] {类名 (实参表), ...};
  - // 上面的写法需要编译器支持 C++11 标准
  - delete[] 对象数组指针;

**知识点**

* 在类的成员函数的声明与实现分开写时，要注意在实现部分一定要在函数名前加 类名::
* 在类的定义时，注意大括号{}后边一定要加分号 ';'
* 如果类内的成员函数设为访问权限 private，而且在类内是没有被调用，则在代码区是没有映射区域的在汇编代码中是找不到它的对应名字的。
* 如果类内的成员函数设为访问权限 public，则是在代码区映射内存的，可以使用汇编代码中对应的函数名调用该成员函数，效果一样


## 四、构造函数与初始化表



